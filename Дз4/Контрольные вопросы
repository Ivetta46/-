Ответы на контрольные вопросы: 

1) Обращение к полю осуществляется через “.” 

Для обращения через указатель используется стрелка “->”.  

Инициализация - через {}.  

Любые неинициализированные элементы внешних или статических структур по умолчанию равны 0. 

struct Name_age{ 

    int year; 

    int age; 

}; 

Name_age John = {2015};         // John.year = 2015, John.age = 0  
2)
Битовое поле - это особый тип структуры, определяющей, какую длину имеет каждый член. Стандартный вид объявления битовых полей: 
 
struct (Name) { 
тип имя1: длина; 
тип имя2: длина; 
... 
тип имяN: длина; 
} 

Битовые поля должны объявляться как int, unsigned или signed. Битовые поля длиной 1 должны объявляться как unsigned, поскольку 1 бит не может иметь знака. 
В C++ битовые поля в структурах обычно используются в низкоуровневом программировании, когда работа идет со значениями, занимающими не байты, а отдельные биты. Так же битовые поля удобно  использовать для решения задач связанных с булевой логикой. Например, шифрование данных. 
3) Объединение - это формат данных, который может хранить разные типы данных в пределах одной области памяти, но в каждую единицу времени только один из них. То есть, в то время как структура может содержать, например, int и long, и double, объединение может содержать int или long, или double. 
union one4all { 

   int int_val;  

   long long_val;  

   douЫe douЬle_val; 
}; 

Можем использовать переменную one4all для хранения int, long или doube, если делать это не одновременно: 

one4all pail;  

pail.int_val = 15; 

cout << pail.int_val; 

 pail.double_val = 1.38; 

cout << pail.double_val; 

Таким образом, pail может служить как переменная int в одном случае и как переменная double - в другом.  

Раньше каждый байт памяти был на вес золота, приходилось экономить на всём. Поэтому объединение было нужно для того, чтобы помочь программисту сделать оптимальную и экономную программу, занимающую маленькие объемы памяти. На сегодняшний день экономия памяти не так актуальна, как 15-20 лет назад. Поэтому объединения сейчас практически не используются.  
4) Перегрузка подразумевает создание функции, название которой содержит слово operator и символ перегружаемого оператора. Функция оператора может быть определена как член класса, либо вне класса.  

Возвр_тип operator (аргумент){ 

    ….. 

} 

5) std::istream (ввод) и std::ostream (вывод) обеспечивают возможность использования перегруженных операторов '<<' и '>>', форматирования вывода, преобразование чисел в строки и наоборот и т.д. 

Передача объектов производится по ссылке для эффективности, чтобы не делать копию объекта. => перегрузка будет использовать один и тот же объект без копирования.  
Поскольку у нас есть только ссылка на istream, мы не можем вернуть сам объект istream (который может иметь тип, не определенный в точке определения operator<<), а только ту ссылку, которая у нас есть. 
6) Классы enum (или «перечисления с областью видимости») добавляют перечислениям локальную область видимости. enum представляет собой альтернативный const способ создания символьных констант. Он также позволяет определять новые типы, но в очень ограниченной манере. 

Конкретные значения элементов перечислений можно устанавливать явно посредством операции присваивания:  

enum bits { one = 1, two = 2, four = 4, eight = 8); 

 Присваиваемые значения должны быть целыми. Явно устанавливать можно лишь некоторые из перечислителей: 

 enum bigstep { first, second = 100, third ) ;  

В этом случае first получает значение 0 по умолчанию. Каждый последующий неинициализированный перечислитель увеличивается на единицу по сравнению с предыдущим. Поэтому third имеет значение 101. 

Мы можем использовать перечисления для определения символических констант для операторов switch.  

После ключевого слова switch в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями после оператора сase. И если совпадение будет найдено, то будет выполняться определенный блок сase. 

В конце конструкции switch может стоять блок default. Он необязателен и выполняется в том случае, если значение после switch не соответствует ни одному из операторов case. 

switch(выражение) { 

    case константа_1: инструкции_1; 

    case константа_2: инструкции_2; 

    default: инструкции; 

} 
