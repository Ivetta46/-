Ответы на контрольные вопросы: 

1) Встраивание функции - это способ оптимизации, при котором вызов функции заменяется ее телом. При компиляции кода все встроенные функции раскрываются на месте, то есть вызов функции заменяется копией содержимого самой функции.  

Встраивание функций используется для экономии процессорного времени, затрачиваемого на вызов функции. 

2)  Ключевое слово auto при инициализации переменной может использоваться вместо типа переменной, чтобы сообщить компилятору, что он должен присвоить тип переменной исходя из инициализируемого значения. (означает, что переменная находится в automatic storage и время жизни такой переменной local lifetime, то есть указываем, что данная переменная лежит в стеке)  

auto нельзя использовать в качестве параметра функции и изменений в этом поведении не предвидится.  

3) Аргумент по умолчанию – это такой аргумент функции, который мы можем не указывать при вызове функции. Он добавляется компилятором по умолчанию автоматически. 

 Аргументы по умолчанию должны быть заданы в прототипе функции.  Если в функции несколько параметров, то параметры, которые опускаются должны находиться правее остальных. Таким образом, если опускается самый первый параметр функции, то все остальные параметры тоже должны быть опущены.  

returned_type FuncName(type1 v1 = val1, type2 v2 = val2, ..., typeN vN = valN) 

{ 

// ...  

} 

Где type1, type2, …, typeN – типы переменных v1, v2, …, vN; 

val2, …, valN – значения, которое присваиваются по умолчанию переменным v2, …, vN. 
4) Аргументы, определенные по умолчанию, позволяют вызывать одну и ту же функцию с указанием различного количества аргументов. А полиморфизм функций, также называемый перегрузкой функций, предоставляет возможность использовать несколько функций с одним именем. Перегрузка функций означает возможность привязки более чем одной функции к одному и тому же имени, что позволяет говорить о перегрузке имен. Таким образом, перегрузка функций нужна для того, чтобы избежать дублирования имён функций, выполняющих сходные действия, но с различной программной логикой. 
5) А) Передача функции в функцию осуществляется с помощью указателей на функцию.  

void function(double (*f)(double)) 

Вместо (*f) компилятор понимает и привычное f. Аналогично, можно передавать в функции и другие функции. 
void function(double (*f)(double)) 

 

Вместо (*f) компилятор понимает и привычное f. Аналогично, можно передавать в функции и другие функции. 

 

Б) Лямбда-выражение позволяет нам определять анонимную функцию внутри другой функции.  

int main() { 

 []() {}; // определяем лямбда-выражение без захватов, без параметров и без возвращаемого типа  

return 0;  

} 

Если лямбда имеет пустой список захвата, мы можем использовать обычный указатель на функцию. 

Для лямбда-выражений можно использовать  std::function<>,  даже если они что-то захватывают. Тип внутри  std::function  шаблон должен быть типом функции, соответствующим функции, которую мы хотим сохранить. Например, для хранения функции, которая принимает два int и возвращает void, мы бы сделали:  

                                                                   std::function<void (int, int)>. 
 
6) Cсылка - это указатель, но без & и * (операций разыменования) 

Передача аргументов в функцию по значению означает, что когда функция вызывается, ей передаются в качестве фактических параметров (аргументов) не указанные переменные, а копии значений этих переменных. Сами переменные к этим копиям уже никакого отношения не имеют. 

Для передачи аргумента по ссылке нужно воспользоваться указателями. Передаются адреса переменных, а не их значения. 

Передача массива в функцию: 

ret_type funcName(datatype arrayName[arraySize]) { 

 // ... 

 } 

Или 

template<std::size_t N> void f(int (&arr)[N]) {} 

И другие контейнеры в функции: 

template <typename Container>  

inline void printcontainer(const Container &container) 

Ссылки, используемые в качестве параметров функции, также могут быть константными. Это позволяет получить доступ к аргументу без его копирования, гарантируя, что функция не изменит значение, на которое ссылается ссылка. 

// S- это константная ссылка на переданный аргумент, а не копия аргумента 

void funcName (const int &S) 

{ 

	S = 8;  

} 
