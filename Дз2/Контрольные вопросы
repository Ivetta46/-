Ответы на контрольные вопросы: 

1) Про стек: 

Применяется, когда новые данные размещаются поверх старых (в смежных ячейках памяти); а потом удаляются, после того как программа закончит работу с ними. Программа отслеживает состояние стека с помощью двух указателей. Один указывает на базу стека, с которой начинается выделенная область памяти, а другой - на вершину стека, которая представляет собой следующую ячейку свободной памяти. Когда происходит вызов функции, ее автоматические переменные добавляются в стек, а указатель вершины устанавливается на свободную ячейку памяти, следующую за только что размещенными переменными. После завершения функции указатель вершины снова принимает значение, которое он имел до вызова функции. В результате освобождается память, которая использовалась для хранения новых переменных. 

В стеке хранятся локальные переменные, те, которые объявляются внутри функций.  

Про кучу: 

Отслеживает память, которая используется для динамического выделения. Данные кучи можно найти с помощью “оглавления”.  

Куча дает огромный размер памяти. Перед началом работы программы выполняется инициализация кучи, в ходе которой изначально выделенная под нее память отмечается как свободная.  

В куче хранятся глобальные переменные, которые хранятся во всем потоке (используются в любом месте файла, после их объявления). 

2) Дело в том, что имя массива является по сути адресом первого элемента ( int a[3] = {1, 2, 3}; ) Однако переменная a и указатель на a являются не одним и тем же объектом. Информация о типе данных у них разная (тип переменной a является a[3], а у указателя - int*) 

3) В случае работы с памятью на “низком” уровне программист имеет дело не с переменными, а с областями памяти, внутри которых он может размещать данные в любой последовательности, разных типов данных. Поэтому на программиста ложится ответственность за правильность размещения данных. Так же небезопасность заключается в доступности (или утечке) памяти.  
4)  

Python                           C++ 

list                             std:: vector<тип> или vector<std:: string> 

list.append()                    push_back / push_front (добавление в конец/начало) 

List.clear()                     namevector.clear() 

For item in some_list            list <int>::iterator i; Или for(инициализ. ; условие ; увел. / уменьш. Переменной){}  

str                              string 

5) Память, выделенная динамически с помощью оператора new , может быть освобождена с помощью delete. Оператор delete вызывает функцию operator delete, которая освобождает память.  

Delete[] используется для удаления массивов. delete используется для удаления объектов без массива.  

То есть: 

Использовать delete[], если для размещения массива применялся new[] 

Использовать delete(без скобок), если применялся new для размещения отдельного элемента. 
 
